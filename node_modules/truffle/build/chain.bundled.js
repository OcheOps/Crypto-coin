#!/usr/bin/env node

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1257);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ 1:
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ 11:
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ 119:
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),

/***/ 1257:
/***/ (function(module, exports, __webpack_require__) {


var IPC = __webpack_require__(198).IPC;
var TestRPC = __webpack_require__(197);
var path = __webpack_require__(0);
var debug = __webpack_require__(33);

/*
 * Loggers
 */
var ipcDebug = debug("chain:ipc");


/*
 * Options
 */

// This script takes one argument: A strinified JSON object meant
// to be parsed and then passed to TestRPC.server().
var ipcNetwork;
var options;

var args = process.argv.slice(2);
if (args.length == 2) {
  ipcNetwork = args[0];
  options = args[1];
} else if (args.length == 1) {
  ipcNetwork = "develop";
  options = args[0];
} else {
  ipcNetwork = "develop";
  options = "{}";
}

try {
  options = JSON.parse(options);
} catch (e) {
  throw new Error("Fatal: Error parsing arguments; please contact the Truffle developers for help.");
}

options.host = options.host || "127.0.0.1";
options.port = options.port || 9545;
options.network_id = options.network_id || 4447;
options.mnemonic = options.mnemonic || "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat";
options.gasLimit = options.gasLimit || 0x47e7c4;


/*
 * Logging
 */

// constructor
function Logger() {
  this.messages = [];

  this.nextSubscriberID = 1;
  this.subscribers = {};
}

// subscribe to log events with provided callback
// sends prior unsent messages, as well as new messages
// returns `unsubscribe` cleanup function
Logger.prototype.subscribe = function(callback) {
  var self = this;

  // flush messages
  var messages = this.messages;
  this.messages = [];
  messages.forEach(function(message) {
    callback(message);
  });

  // save subscriber
  var subscriberID = this.nextSubscriberID++;
  this.subscribers[subscriberID] = callback;

  // return cleanup func
  var unsubscribe = function() {
    delete self.subscribers[subscriberID];
  };

  return unsubscribe;
};

// log a message to be sent to all active subscribers
// buffers if there are no active subscribers (to send on first subscribe)
Logger.prototype.log = function(message) {
  var self = this;

  var subscriberIDs = Object.keys(this.subscribers)
  if (subscriberIDs.length == 0) {
    this.messages.push(message);

    return;
  }

  subscriberIDs.forEach(function(subscriberID) {
    var callback = self.subscribers[subscriberID];

    callback(message);
  });
};


/*
 * Supervisor
 */

// constructor - accepts an object to assign to `ipc.config`
function Supervisor(ipcConfig) {
  var self = this;

  // init IPC
  this.ipc = new IPC();
  // set config
  Object.keys(ipcConfig).forEach(function(key) {
    self.ipc.config[key] = ipcConfig[key];
  });

  this.mixins = [];
}

// include mixin
Supervisor.prototype.use = function(mixin) {
  this.mixins.push(mixin);
};

// dispatch event to all relevant mixins (ones that define `event` method)
Supervisor.prototype.handle = function(event, args) {
  var self = this;

  args = Array.prototype.slice.call(args);

  this.mixins.forEach(function(mixin) {
    if (mixin[event]) {
      mixin[event].apply(mixin, [self].concat(args));
    }
  });
};

// start the IPC server and hook up all the mixins
Supervisor.prototype.start = function() {
  var self = this;

  var ipc = this.ipc;

  // socket filename
  var dirname = ipc.config.socketRoot;
  var basename = `${ipc.config.appspace}${ipc.config.id}`;
  var servePath = path.join(dirname, basename);

  ipc.serve(servePath, function() {
    self.handle('start', arguments);

    ipc.server.on('connect', function() {
      self.handle('connect', arguments);
    });

    ipc.server.on('socket.disconnected', function() {
      self.handle('disconnect', arguments);
    });
  });

  ipc.server.start();
}

// external interface for mixin to emit socket events
Supervisor.prototype.emit = function(socket, message, data, options) {
  options = options || {};
  options.silent = options.silent || false;

  // possibly override silent
  var currentlySilent = this.ipc.config.silent;
  if (options.silent) {
    this.ipc.config.silent = true;
  }

  this.ipc.server.emit(socket, message, data);

  // reset
  this.ipc.config.silent = currentlySilent;
};

// external interface for mixin to exit
Supervisor.prototype.exit = function() {
  this.ipc.server.stop();
  this.handle('exit', arguments);
}


/*
 * Lifecycle
 * (quit on last connection)
 */
function LifecycleMixin() {
  var self = this;
}

// start counting active connections
LifecycleMixin.prototype.start = function(supervisor) {
  this.connections = 0;
};

// increment
LifecycleMixin.prototype.connect = function(supervisor) {
  this.connections++;
};

// decrement - invoke supervisor exit if no connections remain
LifecycleMixin.prototype.disconnect = function(supervisor) {
  this.connections--;

  if (this.connections <= 0) {
    supervisor.exit();
  }
};


/*
 * TestRPC Server
 */

// constructor - accepts options for TestRPC
function TestRPCMixin(options) {
  this.testrpc = TestRPC.server(options);
}

// start TestRPC and capture promise that resolves when ready
TestRPCMixin.prototype.start = function(supervisor) {
  var self = this;

  this.ready = new Promise(function(accept, reject) {
    self.testrpc.listen(options.port, options.hostname, function(err, state) {
      if (err) {
        reject(err);
      }

      accept(state);
    });
  });
};

// wait for TestRPC to be ready then emit signal to client socket
TestRPCMixin.prototype.connect = function(supervisor, socket) {
  var self = this;
  this.ready.then(function() {
    supervisor.emit(socket, 'truffle.ready');
  });
}

// cleanup TestRPC process on exit
TestRPCMixin.prototype.exit = function(supervisor) {
  this.testrpc.close(function(err) {
    if (err) {
      console.error(err.stack || err);
      process.exit(1);
    } else {
      process.exit();
    }
  });
};


/*
 * Logging over IPC
 */

// constructor - takes Logger instance and message key (e.g. `truffle.ipc.log`)
function LoggerMixin(logger, message) {
  this.logger = logger;
  this.message = message;
}

// on connect, subscribe client socket to logger
LoggerMixin.prototype.connect = function(supervisor, socket) {
  var self = this;

  var unsubscribe = this.logger.subscribe(function(data) {
    supervisor.emit(socket, self.message, data, {silent: true});
  });

  socket.on('close', unsubscribe);
};


/*
 * Process event handling
 */
process.on('uncaughtException', function(e) {
  console.error(e.stack);
  process.exit(1);
})


/*
 * Main
 */
var ipcLogger = new Logger();
var testrpcLogger = new Logger();

var supervisor = new Supervisor({
  appspace: "truffle.",
  id: ipcNetwork,
  retry: 1500,
  logger: ipcLogger.log.bind(ipcLogger)
});

ipcLogger.subscribe(ipcDebug);

options.logger = {log: testrpcLogger.log.bind(testrpcLogger)};

supervisor.use(new LifecycleMixin());
supervisor.use(new TestRPCMixin(options));
supervisor.use(new LoggerMixin(ipcLogger, 'truffle.ipc.log'));
supervisor.use(new LoggerMixin(testrpcLogger, 'truffle.testrpc.log'));
supervisor.start();


/***/ }),

/***/ 131:
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(146);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof 